/** Задание: решить систему дифференциальных уравнений:
   dx1/dt=-310*x1-3000*x2+1/(10*t^(2)+1); dx2/dt=x1+e^(-2t);
   x1(0)=0; x2(0)=1; t[0,0.4]; h_print=0.02;
   1.) С помощью программы RKF45 с EPS=0.0001;
   2.) Методом Рунге-Кутты 4-й степени точности
   Zn+1=Zn+(k1+3k2+3k3+k4)/8;
   k1=hf(tn,Zn); k2=hf(tn+h/3,Zn+k1/3);
   k3=hf(tn+2h/3, Zn-k1/3+k2); k4=hf(tn+h, Zn+k1-k2+k3);
   с шагом точности h_print=0.01, любой другой позволяющий получить качественно верное решение.
 */

#include <cmath>
#include <cstdio>
#include "rkf45.c"

using namespace std;

int RKF_45();
int RK_4();
int User_function(int n, double t, double *x, double *dxdt);

int main() {
    printf("----------Method RKF45----------\n");
    RKF_45();
    printf("-----------Method RK4-----------\n");
    RK_4();
    return 0;
}

int RKF_45() { // Решение системы уравнений с помощью библиотечной функции RKF45
    double x[2]; // Значения x1, x2 на i-ом шаге
    double dxdt[2]; // Результат вычисления функций на i-ом шаге
    double t = 0.0; // Начальное значение
    double x1; // Стартовая точка
    double x2; // Точка выходы, в которой получено решение
    double relerr = 1.0e-4; // Относительная погрешность
    double abserr = 1.0e-4; // Абслютная погрешность
    int fail = 0; // Статус выделения памяти для рабочего пространства
    int step = 0; // Шаг
    int n = 2; // Количестов уравнений
    int flag = 1; // Индикатор статуса интегрирования
    int nfe = 0; // Кол-во выполненных шагов
    int maxfe = 5000; // Максимальное кол-во шагов
    rkfinit(n, &fail);
    if (fail == 0) { // Проверка статус выделения памяти для рабочего пространства
        x[0] = 0.0; // Начальное значение x1
        x[1] = 1.0; // Начальное значение x2
        printf("      t        x[0]       x[1]\n");
        printf("--------------------------------\n");
        for (step = 0; step <= 0.4 / 0.2; ++step) { // 0.02 - шаг печати
            x2 = 0.02 * step;
            x1 = x2 - 0.02;
            rkf45(User_function, n, x, dxdt, &x1, x2, &relerr, abserr, &t, &nfe, maxfe, &flag);
            printf("%10.6f %10.6f %10.6f \n", x1, x[0], x[1]);
        }
        rkfend();
        printf("nfe         : %d\n", nfe); // Кол-во выполненных шагов
        printf("step size   : %f\n\n", t); // Величина шага
    }
    return 0;
}

int RK_4() { // Решение системы уравнений методом Рунге-Кутты 4 степени самостоятельно
    double k1[2], k2[2], k3[2], k4[2], z[2], x[2], dxdt[2];
    int n = 2; // Количестов уравнений
    x[0] = 0.0; // Начальное значение x1
    x[1] = 1.0; // Начальное значение x2
    printf("      t        x[0]       x[1]\n");
    printf("-------------------------------- \n");
    double t = 0.0; // Начальное значение
    double H = 0.0001; // Величина шага вычислений
    int k = 0; // Кол-во выполненных шагов 4200
    int step = int (0.4 / H * 0.05); // Шаг печати 200
    while (t < (0.4 + step * H)) { // 0.42
        k++;
        t = t + H;
        //-----1-----
        User_function(n, t, x, dxdt);
        k1[0] = H * dxdt[0];
        k1[1] = H * dxdt[1];
        z[0] = x[0] + k1[0] / 3.0;
        z[1] = x[1] + k1[1] / 3.0;
        //-----2-----
        User_function(n, (t + H / 3.0), z, dxdt);
        k2[0] = H * dxdt[0];
        k2[1] = H * dxdt[1];
        z[0] = x[0] - k1[0] / 3.0 + k2[0];
        z[1] = x[1] - k1[1] / 3.0 + k2[1];
        //-----3-----
        User_function(n, (t + 2.0 * H / 3.0), z, dxdt);
        k3[0] = H * dxdt[0];
        k3[1] = H * dxdt[1];
        z[0] = x[0] + k1[0] - k2[0] + k3[0];
        z[1] = x[1] + k1[1] - k2[1] + k3[1];
        //-----4-----
        User_function(n, (t + H), z, dxdt);
        k4[0] = H * dxdt[0];
        k4[1] = H * dxdt[1];
        x[0] = x[0] + (k1[0] + 3.0 * k2[0] + 3.0 * k3[0] + k4[0]) / 8.0;
        x[1] = x[1] + (k1[1] + 3.0 * k2[1] + 3.0 * k3[1] + k4[1]) / 8.0;
        if (k % step == 0) { // Шаг печати 4200/200=21
            printf("%10.6f %10.6f %10.6f  \n", (t-step*H), x[0], x[1]);
        }
    }
    printf("%d \n", k); // 0.4/H
    return 0;
}

int User_function(int n, double t, double *x, double *dxdt) {
    dxdt[0] = -310.0 * x[0] - 3000.0 * x[1] + 1/((10*t*t)+1);
    dxdt[1] = x[0] + exp(-2.0 * t);
}
