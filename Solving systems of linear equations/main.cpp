/** Задана система алгебраических уравнений A⋅X_1=b, где матрица А зависит от параметра. Используя программы
 * DECOMP и SOLVE, решить систему, изменяя параметр следующим образом: p=1, 0.1, 0.01, 0.0001, 0.000001.
 * Осуществить левую трансформацию Гаусса (A^T⋅A⋅X_2=A^T⋅b) и вновь решить систему. Проанализировать связь
 * числа обусловленности COND и величины δ=‖X_1-X_2 ‖⁄‖X_1 ‖.
 */

#include <math.h>
#include <stdio.h>
#include <iostream>
#include "cmath.h"

#define mdim 8

using namespace std;

int main () {
    double cond, det; // Массивы для работы
    double aT[mdim][mdim], bT[mdim][mdim]; // Транспонированная матрица a и b
    double aTM[mdim][mdim], bTM[mdim]; // Массивы хранящие результат умножения исходных массивов на транспонированную матрицу aT
    double param[5] = {1.0, 0.1, 0.01, 0.0001, 0.000001};// массив хранящий значения параметра "p"
    double CondA[5], DetA[5], CondAT[5], DetAT[5], delta[mdim];
    int n, pivot[mdim], flag;
    n = 8;

    //
    //цикл по p
    // A, b, F, g, decompA, decompF, погрешность
    // запись и вывод значений p dec1, dec2, погрешность
    //

    for (int N = 0; N < 5; N++) {
//**************Инициализируем значениями матрицу A и вектор B****************************************
// __________________________________________________________________________________________________
//|                                  Матрица А                                                       |
//|__________________________________________________________________________________________________|
        double a [8][8]= {param[N] - 3.0,  -4.0,  -4.0,   7.0,  2.0,  3.0,  8.0,  7.0,             //|
                                     0.0, -15.0,  -1.0,   5.0, -3.0,  6.0,  6.0, -6.0,             //|
                                    -4.0,   2.0, -16.0,   7.0,  0.0,  8.0, -7.0,  6.0,             //|
                                     0.0,   8.0,  -5.0, -11.0,  1.0,  0.0,  4.0,  5.0,             //|
                                     8.0,   6.0,  -8.0,   4.0, 27.0, -7.0, -1.0,  5.0,             //|
                                    -4.0,  -2.0,   1.0,   2.0, -8.0, 10.0,  7.0,  0.0,             //|
                                     0.0,  -1.0,   5.0,   2.0, -8.0,  2.0, -2.0,  0.0,             //|
                                     0.0,  -8.0,  -7.0,   3.0, -7.0, -4.0, -8.0,  5.0};            //|
//|__________________________________________________________________________________________________|
//|                                  Вектор B                                                        |
//|__________________________________________________________________________________________________|
        double b[8] = {2.0 * param[N] + 54.0, -72.0, -33.0, -15.0, 180.0, -5.0, -14.0, -131.0};    //|
//|__________________________________________________________________________________________________|

//**************Получим транспонированную матрицу aT**************************************************
        for(int i=0; i<mdim; i++){
            for(int j=0; j<mdim; j++){
                aT[j][i]=a[i][j];
            }
        }

//**************Умножаем транспонированную матрицу aT на исходные массивы a и b, получим aTM и bTM****
        for (int i = 0; i < mdim; i++){
            for (int j = 0; j < mdim; j++){
                aTM[i][j]=0;
                bTM[i]=0;
                for (int k = 0; k < mdim; k++){
                    aTM[i][j] = aTM[i][j] + aT[i][k] * a[k][j];
                    bTM[i] = bTM[i] + aT[i][k] * b[k];
                }
            }
        }

//*****************Решение системы c a и b*************************************************************
        printf("------------------------------------------Decomp A and B---------------------------------------------\n");
        printf("                                       Шаг = %i, p = %f\n", N+1, param[N]);
        decomp(n, mdim, *a, &cond, pivot, &flag);

        if (flag != 0) {
            printf("decomp could not allocate workspace\n");
            goto ProgStop;
        }
        if ((cond + 1.0) == cond) {
            printf("Singular Matrix\n");
            goto ProgStop;
        }

        solve(n, mdim, *a, b, pivot);

        printf("solution    =     [ ");
        for (int i = 0; i < n; i++) {
            printf("%8.3f, ", b[i]);
        }
        printf("]\n");
        printf("\n");
        printf("condition number = %e\n", cond);
        CondA[N] = cond;

        det = pivot[n - 1];
        for (int i = 0; i < n; i++) {
            det = det * a[i][i];
        }
        printf("\nComputed determinant  = %f\n", det);
        DetA[N] = det;
        //printf("determinant should be = __\n");
        printf("*****************************************************************************************************\n");

//*****************Решение системы c aTM и bTM*************************************************************
        printf("------------------------------------------Decomp AT and BT-------------------------------------------\n");
        printf("                                       Шаг = %i, p = %f\n", N+1, param[N]);
        decomp(n, mdim, *aTM, &cond, pivot, &flag);

        if (flag != 0) {
            printf("decomp could not allocate workspace\n");
            goto ProgStop;
        }
        if ((cond + 1.0) == cond) {
            printf("Singular Matrix\n");
            goto ProgStop;
        }

        solve(n, mdim, *aTM, bTM, pivot);

        printf("solution    =     [ ");
        for (int i = 0; i < n; i++) {
            printf("%8.3f, ", bTM[i]);
        }
        printf("]\n");
        printf("\n");
        printf("condition number = %e\n", cond);
        CondAT[N] = cond;

        det = pivot[n - 1];
        for (int i = 0; i < n; i++) {
            det = det * aTM[i][i];
        }
        printf("\nComputed determinant  = %f\n", det);
        DetAT[N] = det;
        //printf("determinant should be = __\n");
        printf("*****************************************************************************************************\n");

        for (int i = 0; i < 8; i++){
            delta[i] = abs((b[i] - bTM[i])) / abs(b[i]);
            printf("Delta  = %.15f\n", delta[i]);
        }
        printf("*****************************************************************************************************\n");
    }
    ProgStop:
    return 0;
}